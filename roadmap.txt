une fourchette = un mutex
donc un tableau de philosophe qui sont des struct et un tableau de fourchette qui sont des mutex
usleep = params en ms

//////////// .h

 📊Structure Philosophe { 
 philo_index  ;
 fourchette de droite ; 
 fourchette de gauche ; 
 nombre de repas mangés ;
 boolean est-il-rassasié? ; 
 bool all_thread_ready;
 heure du dernier repas ; 
 pointeur fourchette de droite et pointeur fourchette de gauche ;
 pthread_t thread_id 
 pointeur vers le data data_container
  ...}

📊Structure fourchette { 
    type_mutex fourchette ;
    id de la fourchette ;
}


📊structure data_container { nombre de philo ;
 time to die ;
 time to eat;
 time to sleep ; 
 nombre de repas max ;
 heure ou demarre la simu ;
 bool is_end? philo die : all philo full
 dc_mutex; eviter les data race quand on lis le dc
 tableau des fourchette t_fork *forks 
 tableau de philosophe t_philo *philos }

📊enum OPcode pour les wrapper des fonction threads et mutex
{
    LOCK,
    UNLOCK,
    INIT,
    DESTROY,
    CREATE,
    JOIN,
    DETACH,
}

///////////  principles

promtpt ex : ./philo nb_phil ttdie tteat ttsleep [nbmaxmeal]

0️⃣////////// main

data_container instance;

Argc correct ? lauch : error msg with err func {ft_printf(custom err msg) + exit FAILURE}
📝 in .h implement colors macro (chat gpt gen)

if correct : 1) parse_input(&data_container, av) in data_container 
             2) init_values(&data_container) (malloc philo, fourchette, )
             3) start simulation(&data_container )
             4) clean table (no leaks ;-)) if philo died | all philo are full 



1️⃣////////// parsing

🛠️atol -> valid input() ? check negative ; nbr is legit (   +--7234^&S✅, +-&^^744❌) ; INT MAX > ?
ret pointeur to nbr
valid_input{
    // skip spaces
    // sign handling : if - error()
    Si tout ses test ont ete passés char *nbr = string d'entree
}

parse_intput {
    data_container->philo_nbr = atol(av[1])
    data_container->ttdie = atol(av[2]) * 1e3
    data_container->tteat = atol(av[3]) * 1e3
    data_container->ttsleep = atol(av[4]) * 1e3

    errorexit si un des parametre <60ms (6e4)

    si av[5]
        data_container->max_meal = atol(av[5])
    sinon
        data_container->max_meal = -1;
    📝 tester en printant tous les parametres precedemment initialisés
    📝 ajouter au .h
}

2️⃣//////////// data_init

// safe func

🛠️ safe malloc is a wrapper to protect malloc in 1line

🛠️ safemutex_handle(*mutex, opcode) = si opcode = LOCK -> handlemuterr(mutex_lock, opcode) sinon si .. : error_exit() 
                                                                    ^^ 0 ou un status

🛠️ safe_thread_handle(*thread, void *(*foo)(void *), void *data, opcode) = == ^^

// err_handle

🛠️ handle_mut_err(int status, opcode)
{
    📝pour les msg d'erreur checker les MAN()

    si le status = 0 tout est bon la fonction est bien exec
    si le status == EINVAL et que l'op code == LOCK || UNLOCK : valeur invalide pour le mutex
    sinon si status == EINVAL et op code == INIT : valeur de l'attribut invalide
    sinon si status = EDEADLK : error_exit(err apporpriee)
    sinon si status = EPERM : error_exit
    sinon si status = EBUSY : error_exit(mutex bloqué)

}

🛠️ pareil pour les threads err

// 🛠️ assinger une fourchette(philo, dc->forks, i = philo position (le premier etant le philo 1 a la position 0)){

    int nbrphilo = philo->dc->philo_nbr
    📝 on peut renommer right_fork et left_fork en first_fork et second_fork 
    📝la fourchette de droite est egale a la position du philo donc
    📝la fourchette de gauche est egale a la position du philo + 1 % philo nbr
    📝EX : fourchette de gauche du 5eme philo = fourchettes[4 (pos dans le tableau) + 1 % 5 (nbr de philo)]
    📝ainsi la fourchette de gauche du dernier philo est la premiere fourchette du tableau

    philo->right/first_fork = &forks[(position + 1) % philonbr]
    philo->left/second_fork = &forks[position]
    
    if (philo->id %2 == 0)
        philo->right/first_fork = &forks[position]
        philo->left/second_fort = &forks[(position + 1) % philonbr]

}

// 🛠️ void philo init(dc) {
    int i;
    t_philo *philo

    tant que i < philonbr
        philo = table->philo + i 
        dc->philo_id = i + 1; philo nb is 0 if not + 1
        is_full = false
        meals counter = 0
        philo->dc = dc
        assinger une fourchette(philo, dc->forks, i = position dans le tableau)

         
}

data_init{
    is_end = false;
    all_thread_ready = false;
    tableau_philo = 🛠️ safemalloc(sizeof(t_philo) * philonbr) 
    🛠️ safe_mutex_handle(&dc->dc_mutex, INIT)
    📝 init tableau de mutex pour les fourchettes
    tableau_fourchette = 🛠️ safemalloc(sizeof(t_fork) * philonbr)
    tant que i < nb philo
        🛠️ safe_mutex_handle(&data_container->forks[i].fork, INIT as opcode)
        data_container->forks[i].fork_id = i;
    🛠️ philo_init(data_container)
}

3️⃣/////////// Dinner start
📝 create dinner.c 
promtpt ex : ./philo nb_phil ttdie tteat ttsleep [nbmaxmeal]

📝 create getters&setters.c

// 🛠️ void *dinner_simulation(void *data) {
    t_philo *philo = (t_philo *)data 
    wait_all_thread(philo->dc) //to synchronize running 

}


si dc->max meals = 0 : return
sinon si il n'y a qu'un philo : 🚨
sinon : tant que i < philo_nbr
    safe_thread_handle(thread = &dc->philo[i].thread_id, pointer_func = dinner_simulation,
    data = &dc->philos[i], opcode = CREATE)

    📝 &dinner_simulation() == dinner_simulation
